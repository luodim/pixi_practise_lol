"use strict";
import * as tslib_1 from "tslib";
import { currentFrameTime } from 'framesync';
import { color, hsla } from 'style-value-types';
import { getProgressFromValue, getValueFromProgress, smooth as calcSmoothing, stepProgress } from './calc';
var noop = function (v) { return v; };
export var appendUnit = function (unit) { return function (v) { return "" + v + unit; }; };
export var applyOffset = function (from, to) {
    var hasReceivedFrom = true;
    if (to === undefined) {
        to = from;
        hasReceivedFrom = false;
    }
    var getOffset = function (v) { return v - from; };
    var applyOffsetTo = function (v) { return v + to; };
    return function (v) {
        if (hasReceivedFrom) {
            return applyOffsetTo(getOffset(v));
        }
        else {
            from = v;
            hasReceivedFrom = true;
            return to;
        }
    };
};
var blend = function (from, to, v) {
    var fromExpo = from * from;
    var toExpo = to * to;
    return Math.sqrt(v * (toExpo - fromExpo) + fromExpo);
};
export var blendColor = function (from, to) {
    var fromColor = (typeof from === 'string') ? color.parse(from) : from;
    var toColor = (typeof to === 'string') ? color.parse(to) : to;
    var blended = tslib_1.__assign({}, fromColor);
    var blendFunc = (from.hue !== undefined ||
        typeof from === 'string' && hsla.test(from)) ? getValueFromProgress
        : blend;
    return function (v) {
        blended = tslib_1.__assign({}, blended);
        for (var key in blended) {
            if (key !== 'alpha' && blended.hasOwnProperty(key)) {
                blended[key] = blendFunc(fromColor[key], toColor[key], v);
            }
        }
        blended.alpha = getValueFromProgress(fromColor.alpha, toColor.alpha, v);
        return blended;
    };
};
export var clamp = function (min, max) { return function (v) { return Math.min(Math.max(v, min), max); }; };
var combineFunctions = function (a, b) { return function (v) { return b(a(v)); }; };
export var pipe = function () {
    var transformers = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        transformers[_i] = arguments[_i];
    }
    return transformers.reduce(combineFunctions);
};
export var conditional = function (check, apply) { return function (v) { return check(v) ? apply(v) : v; }; };
var slowInterpolate = function (input, output, rangeLength, rangeEasing) {
    var finalIndex = rangeLength - 1;
    if (input[0] > input[finalIndex]) {
        input.reverse();
        output.reverse();
    }
    return function (v) {
        if (v <= input[0]) {
            return output[0];
        }
        if (v >= input[finalIndex]) {
            return output[finalIndex];
        }
        var i = 1;
        for (; i < rangeLength; i++) {
            if (input[i] > v || i === finalIndex) {
                break;
            }
        }
        var progressInRange = getProgressFromValue(input[i - 1], input[i], v);
        var easedProgress = (rangeEasing) ? rangeEasing[i - 1](progressInRange) : progressInRange;
        return getValueFromProgress(output[i - 1], output[i], easedProgress);
    };
};
var fastInterpolate = function (minA, maxA, minB, maxB) { return function (v) {
    return (((v - minA) * (maxB - minB)) / (maxA - minA)) + minB;
}; };
export var interpolate = function (input, output, rangeEasing) {
    var rangeLength = input.length;
    return rangeLength !== 2
        ? slowInterpolate(input, output, rangeLength, rangeEasing)
        : fastInterpolate(input[0], input[1], output[0], output[1]);
};
export var generateStaticSpring = function (alterDisplacement) {
    if (alterDisplacement === void 0) { alterDisplacement = noop; }
    return function (constant, origin) { return function (v) {
        var displacement = origin - v;
        var springModifiedDisplacement = -constant * (0 - alterDisplacement(Math.abs(displacement)));
        return (displacement <= 0) ? origin + springModifiedDisplacement : origin - springModifiedDisplacement;
    }; };
};
export var linearSpring = generateStaticSpring();
export var nonlinearSpring = generateStaticSpring(Math.sqrt);
export var wrap = function (min, max) { return function (v) {
    var rangeSize = max - min;
    return ((v - min) % rangeSize + rangeSize) % rangeSize + min;
}; };
export var smooth = function (strength) {
    if (strength === void 0) { strength = 50; }
    var previousValue = 0;
    var lastUpdated = 0;
    return function (v) {
        var currentFramestamp = currentFrameTime();
        var timeDelta = (currentFramestamp !== lastUpdated) ? currentFramestamp - lastUpdated : 0;
        var newValue = timeDelta ? calcSmoothing(v, previousValue, timeDelta, strength) : previousValue;
        lastUpdated = currentFramestamp;
        previousValue = newValue;
        return newValue;
    };
};
export var snap = function (points) {
    if (typeof points === 'number') {
        return function (v) { return Math.round(v / points) * points; };
    }
    else {
        var i_1 = 0;
        var numPoints_1 = points.length;
        return function (v) {
            var lastDistance = Math.abs(points[0] - v);
            for (i_1 = 1; i_1 < numPoints_1; i_1++) {
                var point = points[i_1];
                var distance = Math.abs(point - v);
                if (distance === 0)
                    return point;
                if (distance > lastDistance)
                    return points[i_1 - 1];
                if (i_1 === numPoints_1 - 1)
                    return point;
                lastDistance = distance;
            }
        };
    }
};
export var steps = function (st, min, max) {
    if (min === void 0) { min = 0; }
    if (max === void 0) { max = 1; }
    return function (v) {
        var progress = getProgressFromValue(min, max, v);
        return getValueFromProgress(min, max, stepProgress(st, progress));
    };
};
export var transformMap = function (childTransformers) { return function (v) {
    var output = tslib_1.__assign({}, v);
    for (var key in childTransformers) {
        if (childTransformers.hasOwnProperty(key)) {
            var childTransformer = childTransformers[key];
            output[key] = childTransformer(v[key]);
        }
    }
    return output;
}; };
//# sourceMappingURL=transformers.js.map